// 1. 结构和操作符

/* 
   JS正则表达式中，都有哪些结构:
     字符字面量、字符组、量词、锚字符、分组、选择分支、反向引用。
*/

{
    // 案例分析
    /ab?(c|de*)+|fg/

    /* 
      1. 由于括号的存在，所以(c|de*)是一个整体结构
      2. 在(c|de*)中，注意其中的量词*，因此e*是一个整体结构。
      3. 又因为分支结构 | 优先级最低，因此c是一个整体、而de*是另一个整体。
      4. 同理，整个正则分成了 a、b?、(...)+、f、g
      5. 而由于分支的原因，又可以分成 ab?(c|de*)+ 和 fg 这两部分。
    */
}


// 2.注意要点

{
    /* 
      匹配字符串整体问题
      因为是要匹配整个字符串，我们经常会在正则前后中加上锚字符 ^ 和 $
      但是位置字符和字符序列优先级要比竖杠高
    */
    /^abc|bcd$/; // 错误写法 -> ^abc 或 bcd$

    /^(abc|bcd)$/; // 正确写法 -> ^abc$ 或 ^bcd$
}


{
    /* 
      量词连缀问题
        假设，要匹配这样的字符串：
        1. 每个字符为a、b、c任选其一
        2. 字符串的长度是3的倍数

    此时正则不能想当然地写成/^[abc]{3}+$/，这样会报错，说+前面没什么可重复的
    */
    /([abc]{3})+/; // 正确写法
}

{
    /* 
      元字符转义问题
        所谓元字符，就是正则中有特殊含义的字符
        所有结构里，用到的元字符总结如下：
        ^ $ . * + ? | \ / ( ) [ ] { } = ! : - ,
        当匹配上面的字符本身时，可以一律转义：
    */

    const string = "^$.*+?|\\/[]{}=!:-,";
    const regex = /\^\$\.\*\+\?\|\\\/\[\]\{\}\=\!\:\-\,/;
    console.log(regex.test(string)); // true
    // 现在的问题是，是不是每个字符都需要转义呢？否，看情况。

    {
        // 跟字符组相关的元字符有[]、^、-。因此在会引起歧义的地方进行转义。例如开头的^必须转义，不然会把整个字符组，看成反义字符组。

        const string = "^$.*+?|\\/[]{}=!:-,";
        const regex = /[\^$.*+?|\\/\[\]{}=!:\-,]/g;
        console.log(string.match(regex));
        // ["^", "$", ".", "*", "+", "?", "|", "\", "/", "[", "]", "{", "}", "=", "!", ":", "-", ","]
    }

    {
        // 我们知道[abc]，是个字符组。如果要匹配字符串"[abc]"时，可以写成 /\[abc\] /，也可以写成 /\[abc] /

        const string = "[abc]";
        const regex = /\[abc]/g;
        console.log(string.match(regex)[0]); // "[abc]"
    }

    {
        // 我们知道量词有简写形式{m,}，却没有{,n}的情况。虽然后者不构成量词的形式，但此时并不会报错。当然，匹配的字符串也是"{,n}"

        const string = "{,3}";
        const regex = /{,3}/g;
        console.log(string.match(regex)[0]); // "{,3}"
    }

    /* 
      其余情况
        比如= ! : - ,等符号，只要不在特殊结构中，也不需要转义。
        但是，括号需要前后都转义的，如/\(123\)/。
        至于剩下的^ $ . * + ? | \ /等字符，只要不在字符组内，都需要转义的
    */
}


// 案例分析

{
    // 身份证
    /^(\d{15}|\d{17}[\dxX])$/;

    /* 
      因为竖杠 | 的优先级最低，所以正则分成了两部分 \d{15} 和 \d{17}[\dxX]
      \d{15}表示15位连续数字
      \d{17}[\dxX]表示17位连续数字，最后一位可以是数字可以大小写字母"x"
    */
}


{
    // IPV4地址
    /^((0{0,2}\d|0?\d{2}|1\d{2}|2[0-4]\d|25[0-5])\.){3}(0{0,2}\d|0?\d{2}|1\d{2}|2[0-4]\d|25[0-5])$/;

    /* 
      1. ((...)\.){3}(...)
      2. 上面的两个(...)是一样的结构。表示匹配的是3位数字。因此整个结构是
        3位数.3位数.3位数.3位数
      3. 然后再来分析(...)
        它是一个多选结构，分成5个部分：
        0{0,2}\d，匹配一位数，包括0补齐的。比如，9、09、009
        0?\d{2}，匹配两位数，包括0补齐的，也包括一位数
        1\d{2}，匹配100到199
        2[0-4]\d，匹配200-249
        25[0-5]，匹配250-255。
    */
}


/* 
  掌握正则表达式中的优先级后，再看任何正则应该都有信心分析下去了
  竖杠的优先级最低，即最后运算
  另外关于元字符转义问题，当自己不确定与否时，尽管去转义，总之是不会错的。
*/