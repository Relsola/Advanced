/* 
  1. 平衡法则

    构建正则有一点非常重要，需要做到下面几点的平衡：
      1. 匹配预期的字符串
      2. 不匹配非预期的字符串
      3. 可读性和可维护性
      4. 效率
*/


/* 
  2. 构建正则前提
    1. 是否能使用正则
      正则太强大了，以至于我们随便遇到一个操作字符串问题时，都会下意识地去想，用正则该怎么做。但我们始终要提醒自己，正则虽然强大，但不是万能的，很多看似很简单的事情，还是做不到的。
      
      比如匹配这样的字符串：1010010001....虽然很有规律，但是只靠正则就是无能为力。

    2. 是否有必要使用正则
      要认识到正则的局限，不要去研究根本无法完成的任务。同时，也不能走入另一个极端：无所不用正则。能用字符串API解决的简单问题，就不该正则出马。


    3. 是否有必要构建一个复杂的正则
*/

{
    // 从日期中提取出年月日
    const string = "2017-07-01";
    const regex = /^(\d{4})-(\d{2})-(\d{2})/;
    console.log(string.match(regex));
    // => ["2017-07-01", "2017", "07", "01", index: 0, input: "2017-07-01"]

    const result = string.split("-")
    console.log(result);
}

{
    // 判断是否有问号
    const string = "?id=xx&act=search";
    console.log(string.search(/\?/)); // 0

    console.log(string.includes("?"));
}

{
    // 获取子串
    const string = "JavaScript";
    console.log(string.match(/.{4}(.+)/)[1]); // Script

    console.log(string.substring(4));
}

{
    // 密码匹配问题，要求密码长度6-12位，由数字、小写字符和大写字母组成，但必须至少包括2种字符

    /(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/;

    // 使用多个小正则:
    const regex1 = /^[0-9A-Za-z]{6,12}$/;
    const regex2 = /^[0-9]{6,12}$/;
    const regex3 = /^[A-Z]{6,12}$/;
    const regex4 = /^[a-z]{6,12}$/;
    function checkPassword(string) {
        if (!regex1.test(string)) return false;
        if (regex2.test(string)) return false;
        if (regex3.test(string)) return false;
        if (regex4.test(string)) return false;
        return true;
    }
}



/* 
  3.准确性

    所谓准确性，就是能匹配预期的目标，并且不匹配非预期的目标。
    这里提到了“预期”二字，那么我们就需要知道目标的组成规则。
    不然没法界定什么样的目标字符串是符合预期的，什么样的又不是符合预期的
*/

{
    /* 
      匹配固定电话：
        055188888888  0551-88888888  (0551)88888888
    */

    // 字符是否出现的情形
    /^\(?0\d{2,3}\)?-?[1-9]\d{6,7}$/g;
    // 虽然也能匹配上述目标字符串，但也会匹配(0551-88888888这样的字符串


    // 了解各部分的模式规则  构建分支  提取公共部分
    /^(0\d{2,3}-?|\(0\d{2,3}\))[1-9]\d{6,7}$/;
}


{
    /* 
      匹配浮点数
        1.23、+1.23、-1.23
        10、+10、-10
        .2、+.2、-.2
    */

    /*
      可以看出正则分为三部分。
      符号部分：[+-]
      整数部分：\d+
      小数部分：\.\d+
      上述三个部分，并不是全部都出现。如果此时很容易写出如下的正则：
    */
    /^[+-]?(\d+)?(\.\d+)?$/; // 此正则看似没问题，但这个正则也会匹配空字符""。


    /*
      要匹配1.23、+1.23、-1.23，可以用/^[+-]?\d+\.\d+$/
      要匹配10、+10、-10，可以用/^[+-]?\d+$/
      要匹配.2、+.2、-.2，可以用/^[+-]?\.\d+$/
      因此整个正则是这三者的或的关系，提取公众部分后
    */
    /^[+-]?(\d+\.\d+|\d+|\.\d+)$/g;
}


/* 
  4. 效率

    保证了准确性后，才需要是否要考虑要优化。大多数情形是不需要优化的，除非运行的非常慢。什么情形正则表达式运行才慢呢？我们需要考察正则表达式的运行过程（原理）。
    正则表达式的运行分为如下的阶段：
      1. 编译
      2. 设定起始位置
      3. 尝试匹配
      4. 匹配失败的话，从下一位开始继续第3步
      5. 最终结果：匹配成功或失败
*/

{
    const regex = /\d+/g;
    console.log(regex.lastIndex, regex.exec("123abc34def"));
    console.log(regex.lastIndex, regex.exec("123abc34def"));
    console.log(regex.lastIndex, regex.exec("123abc34def"));
    console.log(regex.lastIndex, regex.exec("123abc34def"));
    console.log("123abc34def".match(regex));
    // => 0 ["123", index: 0, input: "123abc34def"]
    // => 3 ["34", index: 6, input: "123abc34def"]
    // => 8 null
    // => 0 ["123", index: 0, input: "123abc34def"]
}

{
    // 使用具体型字符组来代替通配符，来消除回溯
    /".*?"/;
    /"[^"]*"/; // 优化



    // 使用非捕获型分组
    /^[+-]?(\d+\.\d+|\d+|\.\d+)$/;
    /^[+-]?(?:\d+\.\d+|\d+|\.\d+)$/; //优化


    // 独立出确定字符
    /a+/;
    /aa*/; // 优化


    // 提取分支公共部分
    /this|that/;
    /th(?:is|at)/; //优化


    // 减少分支的数量，缩小它们的范围
    /red|read/;
    /rea?d/;
    // 此时分支和量词产生的回溯的成本是不一样的。但这样优化后，可读性会降低的。
}