{
    // 按位非 ～ -------------------------------------------------------
    // 按位非操作符用波浪符（~）表示，它的作用是返回数值的一补数。按位非是 ECMAScript 中为数 不多的几个二进制数学操作符之一。看下面的例子：
    let num1 = 25; // 二进制 00000000000000000000000000011001
    let num2 = ~num1 // 二进制 11111111111111111111111111100110
    console.log(num2);

    // 由此可以看出，按位非的最终效果是对 数值取反并减 1
    let a = -10
    console.log(~a + 1); // 10
}


{
    // 按位与 & ------------------------------------------------------
    // 按位与操作符用和号（&）表示，有两个操作数。本质上，按位与就是将两个数的每一个位对齐， 然后基于真值表中的规则，对每一位执行相应的与操作。
    /*
    第一个数值的位  第二个数值的位   结果
          1              1           1
          1              0           0
          0              1           0
          0              0           0
    */
    // 按位与操作在两个位都是 1 时返回 1，在任何一位是 0 时返回 0。 下面看一个例子，我们对数值 25 和 3 求与操作，如下所示：
    let result = 25 & 3;
    console.log(result); // 1
    /* 
    25 = 0000 0000 0000 0000 0000 0000 0001 1001
     3 = 0000 0000 0000 0000 0000 0000 0000 0011
    res= 0000 0000 0000 0000 0000 0000 0000 0001
    */
}

{
    // 按位或 ｜ -------------------------------------------------------
    // 按位或操作符用管道符（|）表示，同样有两个操作数。按位或遵循如下真值表：
    /*
    第一个数值的位  第二个数值的位   结果
          1              1           1
          1              0           1
          0              1           1
          0              0           0
    */
    // 按位或操作在至少一位是 1 时返回 1，两位都是 0 时返回 0。 仍然用按位与的示例，如果对 25 和 3 执行按位或，代码如下所示：
    let result = 25 | 3;
    console.log(result); // 27
    /*
    25 = 0000 0000 0000 0000 0000 0000 0001 1001
     3 = 0000 0000 0000 0000 0000 0000 0000 0011
    res= 0000 0000 0000 0000 0000 0000 0001 1011
    */
}

{
    // 按位异或 ^ -------------------------------------------------------
    // 按位异或用脱字符（^）表示，同样有两个操作数。下面是按位异或的真值表:
    /*
    第一个数值的位  第二个数值的位   结果
          1              1           0
          1              0           1
          0              1           1
          0              0           0
    */
    // 按位异或与按位或的区别是，它只在一位上是 1 的时候返回 1（两位都是 1 或 0，则返回 0）。 对数值 25 和 3 执行按位异或操作：
    let result = 25 ^ 3;
    console.log(result); // 26
    /*
    25 = 0000 0000 0000 0000 0000 0000 0001 1001
     3 = 0000 0000 0000 0000 0000 0000 0000 0011
    res= 0000 0000 0000 0000 0000 0000 0001 1010
    */
}

{
    // 左移 << -------------------------------------------------------
    let oldValue = 2; // 二进制 10
    let newValue = oldValue << 5; // 二进制 1000000
    console.log(newValue); // 64
    // 注意在移位后，数值右端会空出 5 位。左移会以 0 填充这些空位，让结果是完整的 32 位数值。
    // 注意，左移会保留它所操作数值的符号。比如，如果-2 左移 5 位，将得到-64，而不是正 64。
}

{
    // 有符号右移 >> --------------------------------------------------
    // 有符号右移由两个大于号（>>）表示，会将数值的所有 32 位都向右移，同时保留符号（正或负）。 有符号右移实际上是左移的逆运算。比如，如果将 64 右移 5 位，那就是 2：
    let oldValue = 64; // 二进制 1000000
    let newValue = oldValue >> 5; // 二进制 10
    console.log(newValue); // 2
}

{
    // 无符号右移 >>> -------------------------------------------------
    // 无符号右移用 3 个大于号表示（>>>），会将数值的所有 32 位都向右移。对于正数，无符号右移与 有符号右移结果相同。仍然以前面有符号右移的例子为例，64 向右移动 5 位，会变成 2：
    console.log(64 >>> 5);

    // 对于负数，有时候差异会非常大。与有符号右移不同，无符号右移会给空位补 0，而不管符号位是 什么。对正数来说，这跟有符号右移效果相同。但对负数来说，结果就差太多了。无符号右移操作符将负数的二进制表示当成正数的二进制表示来处理。因为负数是其绝对值的二补数，所以右移之后结果变 得非常之大，如下面的例子所示：
    let oldValue = -64; // 二进制 11111111111111111111111111000000
    let newValue = oldValue >>> 5; // 二进制 00000111111111111111111111111110
    console.log(newValue); // 134 217 726。
}


// ----------------------------------------------------------------------
// 实战妙用 持续更新

{
    // 1.判断奇偶数 -------------------------------------------------------
    // 偶数 & 1 = 0
    // 奇数 & 1 = 1
    console.log("2 & 1 偶数为0", 2 & 1) // 0
    console.log("3 & 1 奇数为1", 3 & 1) // 1
}

{
    // 2. 使用^来完成值的交换 ------------------------------------------------
    let a = 2;
    let b = 5;
    a ^= b; b ^= a; a ^= b
    console.log("a = 2 ,b = 5 交换后", a, b);
}

{
    // 3. 使用~进行判断 ------------------------------------------------------
    // 常用判断
    const arr = [1, 2, 3]
    if (arr.indexOf(2) > -1) { }
    // 按位非    ~-1 = -(-1) - 1 取反再 -1 === 0
    if (~arr.indexOf(3)) { console.log("~-1 === 0"); }

}

{
    // 4. 使用&, >>, |来完成rgb值和16进制颜色值之间的转换 ------------------------
    /**
     * 16进制颜色值转RGB
     * @param  {String} hex 16进制颜色字符串
     * @return {String}     RGB颜色字符串
     */
    function hexToRGB(color) {
        color = color.replace('#', '0x')
        const r = color >> 16
        const g = color >> 8 & 0xff
        const b = color & 0xff
        return `rgb(${r}, ${g}, ${b})`
    }

    /**
     * RGB颜色转16进制颜色
     * @param  {String} rgb RGB进制颜色字符串
     * @return {String}     16进制颜色字符串
     */
    function RGBToHex(rgb) {
        var rgbArr = rgb.split(/[^\d]+/)
        var color = rgbArr[1] << 16 | rgbArr[2] << 8 | rgbArr[3]
        return '#' + color.toString(16)
    }

    console.log(hexToRGB('#ffffff'));             // 'rgb(255,255,255)'
    console.log(RGBToHex('rgb(255,255,255)'));     // '#ffffff'
}

{
    // 5. 使用 ~~ 取整 >>1 除2  <<1 乘2 --------------------------------------
    console.log(~~3.1415); // 3
    console.log(5 >> 1); // 奇数会向下取整
    console.log(4 >> 1);
    console.log(5 << 1);
    console.log(4 << 1);
}

{
    // 6. 使用按位异或 ^ 切换 0 和 1 -----------------------------------------
    // 常用 toggle 
    let toggle = 0
    toggle = toggle ? 0 : 1
    console.log("toggle", toggle);

    // 按位异或
    toggle ^= 1
    console.log("toggle", toggle);
}