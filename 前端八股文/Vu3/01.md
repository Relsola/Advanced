## 1. vue2和vue3的区别
1. 监测机制的改变
   - vue3 中使用了ES6 的 <code style="color: #ff502c;">Proxy</code> API 对数据代理，监测的是整个对象，而不再是某个属性。
   - 消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制
   - vue3可以监测到对象属性的添加和删除，可以监听数组的变化；
   - vue3支持 Map、Set、WeakMap 和 WeakSet。

2. <code style="color: #ff502c;">Vue3支持碎片(Fragments)</code> 
   - Vue2在组件中只有一个根节点。
   - Vue3在组件可以拥有多个根节点。

3. API模式不同
   - Vue2与Vue3<code style="color: #ff502c;">最大的</code>区别：Vue2使用<code style="color: #ff502c;">选项式</code>API（Options API）对比Vue3<code style="color: #ff502c;">组合式</code>API（Composition API）

4. 建立数据的方式不同
   - Vue2：这里把数据放入data属性中
   - Vue3：需要使用一个新的setup()方法，此方法在组件初始化构造的时候触发。
   - 使用以下三步来建立响应式数据:
     - 从vue`引入ref或reactive`
     - 简单数据类型使用`ref()`方法处理，复杂类型数据用`reactive()`处理
     - 使用`setup()`方法来`返回`我们的响应性数据，从而我们的`template`可以`获取`这些响应性数据

5. 生命周期钩子不同 — Lifecycle Hooks
   - setup() :开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method
   - onBeforeMount() : 组件挂载到节点上之前执行的函数。
   - onMounted() : 组件挂载完成后执行的函数。
   - onBeforeUpdate(): 组件更新之前执行的函数。
   - onUpdated(): 组件更新完成之后执行的函数。
   - onBeforeUnmount(): 组件卸载之前执行的函数。
   - onUnmounted(): 组件卸载完成后执行的函数
  
   若组件被<keep-alive>包含，则多出下面两个钩子函
   - onActivated(): 被包含在中的组件，会多出两个生命周期钩子函数。被激活时执行 。
   - onDeactivated(): 比如从 A组件，切换到 B 组件，A 组件消失时执行。

6. 父子传参不同，子组件通过defineProps()进行接收，并且接收这个函数的返回值进行数据操作。
**总结： vue3 性能更高, 体积更小, 更利于复用, 代码维护更方便**

## 2. defineProperty和proxy的区别
Vue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。并 劫持各个属性 getter 和 setter，在数据变化时发布消息给订阅者，触发相应的监听回调，而这之间存在几个问题
- 初始化时需要遍历对象所有 key，如果对象层次较深，性能不好
- 通知更新过程需要维护大量 dep 实例和 watcher 实例，额外占用内存较多
- Object.defineProperty 无法监听到数组元素的变化，只能通过劫持重写数方法
- 动态新增，删除对象属性无法拦截，只能用特定 set/delete API 代替
- 不支持 Map、Set 等数据结构

Vue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于Object.defineProperty()，其有以下特点：
1. **Proxy 直接代理整个对象而非对象属性**，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。

2. 它的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部属性才会变成响应式，简单的可以说是按需实现响应式，减少性能消耗。

3. Proxy 可以监听数组的变化。

## 3. Vue3 Diff算法和 Vue2 的区别
我们知道在数据变更触发页面重新渲染，会生成虚拟 DOM 并进行 patch 过程，这一过程在 Vue3 中的优化有如下

**编译阶段的优化：**
- 事件缓存：将事件缓存(如: @click)，可以理解为变成静态的了
- 静态提升：第一次创建静态节点时保存，后续直接复用
- 添加静态标记：给节点添加静态标记，以优化 Diff 过程

**Diff 优化如下**
- Vue2 是全量 Diff，Vue3 是静态标记 + 非全量 Diff
- 使用最长递增子序列优化了对比流程

## 4. composition API 与 options API的区别
1. vue2 采用的就是 optionsAPI
   - 优点:易于学习和使用, 每个代码有着明确的位置 (例如: 数据放 data 中, 方法放 methods中)
   -  缺点: 相似的逻辑, 不容易复用, 在大项目中尤为明显
   -  虽然 optionsAPI 可以通过mixins 提取相同的逻辑, 但是也并不是特别好维护

2. vue3 新增的就是 compositionAPI
   - compositionAPI 是基于 逻辑功能 组织代码的, 一个功能 api 相关放到一起
   - 即使项目大了, 功能多了, 也能快速定位功能相关的 api
   - 大大的提升了 代码可读性 和 可维护性
  
3. vue3 推荐使用 composition API, 也保留了options API
   - 即就算不用composition API, 用 vue2 的写法也完全兼容!!

## 5. Composition API与React Hook很像，区别是什么
从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制
- 不能在循环、条件、嵌套函数中调用Hook
- 必须确保总是在你的React函数的顶层调用Hook
- useEffect、useMemo等函数必须手动确定依赖关系

而Composition API是基于Vue的响应式系统实现的，与React Hook的相比
- 声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢
- Composition API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用
- 响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。
  
虽然Composition API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。

## 6. setup 函数
setup() 函数是 vue3 中，专门为组件提供的新属性。它为我们使用 vue3的 Composition API 新特性提供了统一的入口, setup 函数会在 beforeCreate 、created 之前执行, vue3也是取消了这两个钩子，统一用setup代替, 该函数相当于一个生命周期函数，vue中过去的data，methods，watch等全部都用对应的新增api写在setup()函数中

setup() 接收两个参数 props 和 context。它里面不能使用 this，而是通过 context 对象来代替当前执行上下文绑定的对象，context 对象有四个属性：attrs、slots、emit、expose

里面通过 ref 和 reactive 代替以前的 data 语法，return 出去的内容，可以在模板直接使用，包括变量和方法

```xml
<template>
  <div class="container">
    <h1 @click="say()">{{msg}}</h1>
  </div>
</template>
​
<script>
export default {
  setup (props,context) {
    console.log('setup执行了')
    console.log(this)  // undefined
    // 定义数据和函数
    const msg = 'hi vue3'
    const say = () => {
      console.log(msg)
    }
    // Attribute (非响应式对象，等同于 $attrs)
    context.attrs
    // 插槽 (非响应式对象，等同于 $slots)
    context.slots
    // 触发事件 (方法，等同于 $emit)
    context.emit
    // 暴露公共 property (函数)
    context.expose
​
    return { msg , say}
  },
  beforeCreate() {
    console.log('beforeCreate执行了')
    console.log(this)  
  }
}
</script>
```

## 7. setup语法糖 （script setup语法）
script setup是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。相比于普通的 script 语法更加简洁

要使用这个语法，需要将 `setup` attribute 添加到 `<script>` 代码块上：
```xml
<script setup>
console.log('hello script setup')
</script>
```